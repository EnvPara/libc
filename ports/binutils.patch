diff --git a/bfd/opncls.c b/bfd/opncls.c
index b4d4dcf646..b5e5005d93 100644
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -676,6 +676,7 @@ bfd_openw (const char *filename, const char *target)
 static inline void
 _maybe_make_executable (bfd * abfd)
 {
+#if 0
   /* If the file was open for writing and is now executable,
      make it so.  */
   if (abfd->direction == write_direction
@@ -697,6 +698,7 @@ _maybe_make_executable (bfd * abfd)
 		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
 	}
     }
+#endif
 }
 
 /*
diff --git a/binutils/ar.c b/binutils/ar.c
index 274be4685a..5b2a9a5180 100644
--- a/binutils/ar.c
+++ b/binutils/ar.c
@@ -1113,7 +1113,7 @@ extract_file (bfd *abfd)
   output_file = NULL;
   output_filename = NULL;
 
-  chmod (bfd_get_filename (abfd), buf.st_mode);
+  //chmod (bfd_get_filename (abfd), buf.st_mode);
 
   if (preserve_dates)
     {
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index 2636ab4bcb..3049b6feed 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -1813,7 +1813,7 @@ copy_unknown_object (bfd *ibfd, bfd *obfd)
 
   /* We should at least to be able to read it back when copying an
      unknown object in an archive.  */
-  chmod (bfd_get_filename (obfd), buf.st_mode | S_IRUSR);
+  //chmod (bfd_get_filename (obfd), buf.st_mode | S_IRUSR);
   free (cbuf);
   return TRUE;
 }
@@ -2742,7 +2742,7 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
   for (l = list; l != NULL; l = l->next)
     {
       if (l->obfd == NULL)
-	rmdir (l->name);
+	;//rmdir (l->name);
       else
 	{
 	  bfd_close (l->obfd);
@@ -2750,7 +2750,7 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
 	}
     }
 
-  rmdir (dir);
+  //rmdir (dir);
 }
 
 static void
diff --git a/binutils/rename.c b/binutils/rename.c
index 2dbc86cfd0..0f725d831b 100644
--- a/binutils/rename.c
+++ b/binutils/rename.c
@@ -92,6 +92,7 @@ set_times (const char *destination, const struct stat *statbuf)
 {
   int result;
 
+#if 0
   {
 #ifdef HAVE_GOOD_UTIME_H
     struct utimbuf tb;
@@ -120,6 +121,7 @@ set_times (const char *destination, const struct stat *statbuf)
 
   if (result != 0)
     non_fatal (_("%s: cannot set time: %s"), destination, strerror (errno));
+#endif
 }
 
 #ifndef S_ISLNK
@@ -184,9 +186,9 @@ smart_rename (const char *from, const char *to, int preserve_dates ATTRIBUTE_UNU
 		 setuid bit if the chown succeeds, because we don't
 		 want to introduce an unexpected setuid file owned by
 		 the user running objcopy.  */
-	      chmod (to, s.st_mode & 0777);
-	      if (chown (to, s.st_uid, s.st_gid) >= 0)
-		chmod (to, s.st_mode & 07777);
+	      //chmod (to, s.st_mode & 0777);
+	      //if (chown (to, s.st_uid, s.st_gid) >= 0)
+		//chmod (to, s.st_mode & 07777);
 	    }
 	}
       else
diff --git a/configure b/configure
index be9dd89d9b..ef66817b8b 100755
--- a/configure
+++ b/configure
@@ -3869,6 +3869,9 @@ case "${target}" in
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
+  *-elf-redox)
+    noconfigdirs="$noconfigdirs readline gdb"
+    ;;
 esac
 
 # If we aren't building newlib, then don't build libgloss, since libgloss
diff --git a/configure.ac b/configure.ac
index 532c5c27f9..7f652bd38a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1203,6 +1203,9 @@ case "${target}" in
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
+  *-elf-redox)
+    noconfigdirs="$noconfigdirs readline gdb"
+    ;;
 esac
 
 # If we aren't building newlib, then don't build libgloss, since libgloss
